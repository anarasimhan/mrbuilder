{"version":3,"sources":["../src/markdown.js"],"names":["Renderer","assign","require","unescapeAll","escapeHtml","default_rules","code_inline","tokens","idx","options","env","slf","token","renderAttrs","content","code_block","fence","info","trim","langName","highlighted","i","tmpAttrs","tmpToken","split","highlight","indexOf","attrIndex","attrs","slice","push","langPrefix","image","renderInlineAsText","children","renderToken","hardbreak","softbreak","text","html_block","html_inline","rules","imports","prelude","prototype","l","result","length","name","nextToken","needLf","hidden","block","nesting","tag","xhtmlOut","type","renderInline","len","render","map","renderImport","join","renderPrelude","key","value"],"mappings":"AAAA;;;;;;;AAOA;;;;;;;;;;;;;;kBAuHwBA,Q;;;;AApHxB,IAAMC,SAAcC,QAAQ,8BAAR,EAAwCD,MAA5D;AACA,IAAME,cAAcD,QAAQ,8BAAR,EAAwCC,WAA5D;AACA,IAAMC,aAAcF,QAAQ,8BAAR,EAAwCE,UAA5D;;AAEA;;AAEA,IAAMC,gBAAgB,EAAtB;;AAGAA,cAAcC,WAAd,GAA4B,UAAUC,MAAV,EAAkBC,GAAlB,EAAuBC,OAAvB,EAAgCC,GAAhC,EAAqCC,GAArC,EAA0C;AAClE,QAAMC,QAAQL,OAAOC,GAAP,CAAd;;AAEA,WAAO,UAAUG,IAAIE,WAAJ,CAAgBD,KAAhB,CAAV,GAAmC,IAAnC,GAA0C,yBAC7CL,OAAOC,GAAP,EAAYM,OADiC,CAA1C,GACoB,UAD3B;AAEH,CALD;;AAQAT,cAAcU,UAAd,GAA2B,UAAUR,MAAV,EAAkBC,GAAlB,EAAuBC,OAAvB,EAAgCC,GAAhC,EAAqCC,GAArC,EAA0C;AACjE,QAAMC,QAAQL,OAAOC,GAAP,CAAd;;AAEA,WAAO,SAASG,IAAIE,WAAJ,CAAgBD,KAAhB,CAAT,GAAkC,UAAlC,GAA+C,yBAClDL,OAAOC,GAAP,EAAYM,OADsC,CAA/C,GACoB,kBAD3B;AAEH,CALD;;AAQAT,cAAcW,KAAd,GAAsB,UAAUT,MAAV,EAAkBC,GAAlB,EAAuBC,OAAvB,EAAgCC,GAAhC,EAAqCC,GAArC,EAA0C;AAC5D,QAAMC,QAAQL,OAAOC,GAAP,CAAd;AAAA,QACMS,OAAQL,MAAMK,IAAN,GAAad,YAAYS,MAAMK,IAAlB,EAAwBC,IAAxB,EAAb,GAA8C,EAD5D;;AAGA,QAAIC,WAAW,EAAf;AAAA,QACIC,oBADJ;AAAA,QACiBC,UADjB;AAAA,QACoBC,iBADpB;AAAA,QAC8BC,iBAD9B;;AAGA,QAAIN,IAAJ,EAAU;AACNE,mBAAWF,KAAKO,KAAL,CAAW,MAAX,EAAmB,CAAnB,CAAX;AACH;;AAED,QAAIf,QAAQgB,SAAZ,EAAuB;AACnBL,sBAAcX,QAAQgB,SAAR,CAAkBb,MAAME,OAAxB,EAAiCK,QAAjC,KAA8Cf,WACxDQ,MAAME,OADkD,CAA5D;AAEH,KAHD,MAGO;AACHM,sBAAchB,WAAWQ,MAAME,OAAjB,CAAd;AACH;;AAED,QAAIM,YAAYM,OAAZ,CAAoB,MAApB,MAAgC,CAApC,EAAuC;AACnC,eAAON,cAAc,IAArB;AACH;;AAED;AACA;AACA;AACA,QAAIH,IAAJ,EAAU;AACNI,YAAWT,MAAMe,SAAN,CAAgB,OAAhB,CAAX;AACAL,mBAAWV,MAAMgB,KAAN,GAAchB,MAAMgB,KAAN,CAAYC,KAAZ,EAAd,GAAoC,EAA/C;;AAEA,YAAIR,IAAI,CAAR,EAAW;AACPC,qBAASQ,IAAT,CAAc,CAAC,WAAD,EAAcrB,QAAQsB,UAAR,GAAqBZ,QAAnC,CAAd;AACH,SAFD,MAEO;AACHG,qBAASD,CAAT,EAAY,CAAZ,KAAkB,MAAMZ,QAAQsB,UAAd,GAA2BZ,QAA7C;AACH;;AAED;AACAI,mBAAW;AACPK,mBAAON;AADA,SAAX;;AAIA,eAAOF,WAAP;AACH;;AAGD,WAAO,eAAeT,IAAIE,WAAJ,CAAgBD,KAAhB,CAAf,GAAwC,GAAxC,GACEQ,WADF,GAEE,iBAFT;AAGH,CA/CD;;AAkDAf,cAAc2B,KAAd,GAAsB,UAAUzB,MAAV,EAAkBC,GAAlB,EAAuBC,OAAvB,EAAgCC,GAAhC,EAAqCC,GAArC,EAA0C;AAC5D,QAAMC,QAAQL,OAAOC,GAAP,CAAd;;AAEA;AACA;AACA;AACA;;AAEAI,UAAMgB,KAAN,CAAYhB,MAAMe,SAAN,CAAgB,KAAhB,CAAZ,EAAoC,CAApC,IACIhB,IAAIsB,kBAAJ,CAAuBrB,MAAMsB,QAA7B,EAAuCzB,OAAvC,EAAgDC,GAAhD,CADJ;;AAGA,WAAOC,IAAIwB,WAAJ,CAAgB5B,MAAhB,EAAwBC,GAAxB,EAA6BC,OAA7B,CAAP;AACH,CAZD;;AAeAJ,cAAc+B,SAAd,GAA0B,UAAU7B,MAAV,EAAkBC,GAAlB,EAAuBC,OAAvB,CAA+B,UAA/B,EAA2C;AACjE,WAAO,UAAP;AACH,CAFD;AAGAJ,cAAcgC,SAAd,GAA0B,UAAU9B,MAAV,EAAkBC,GAAlB,EAAuBC,OAAvB,CAA+B,UAA/B,EAA2C;AACjE,WAAO,QAAP;AACH,CAFD;;AAKAJ,cAAciC,IAAd,GAAqB,UAAU/B,MAAV,EAAkBC,GAAlB,CAAsB,mBAAtB,EAA2C;AAC5D,WAAO,MAAM,yBAAeD,OAAOC,GAAP,EAAYM,OAA3B,CAAN,GAA4C,GAAnD;AACH,CAFD;;AAKAT,cAAckC,UAAd,GAA4B,UAAUhC,MAAV,EAAkBC,GAAlB,CAAsB,mBAAtB,EAA2C;AACnE,WAAOD,OAAOC,GAAP,EAAYM,OAAnB;AACH,CAFD;AAGAT,cAAcmC,WAAd,GAA4B,UAAUjC,MAAV,EAAkBC,GAAlB,CAAsB,mBAAtB,EAA2C;AACnE,WAAOD,OAAOC,GAAP,EAAYM,OAAnB;AACH,CAFD;;AAKA;;;;;AAKe,SAASd,QAAT,GAAoB;;AAE/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,SAAKyC,KAAL,GAAaxC,OAAO,EAAP,EAAWI,aAAX,CAAb;AACA,SAAKqC,OAAL,GAAe;AACX,8CAAsC;AAD3B,KAAf;AAGA,SAAKC,OAAL,GAAe,EAAf;AACH;;AAGD;;;;;AAKA3C,SAAS4C,SAAT,CAAmB/B,WAAnB,GAAiC,SAASA,WAAT,CAAqBD,KAArB,EAA4B;AACzD,QAAIS,UAAJ;AAAA,QAAOwB,UAAP;AAAA,QAAUC,eAAV;;AAEA,QAAI,CAAClC,MAAMgB,KAAX,EAAkB;AACd,eAAO,EAAP;AACH;;AAEDkB,aAAS,EAAT;;AAEA,SAAKzB,IAAI,CAAJ,EAAOwB,IAAIjC,MAAMgB,KAAN,CAAYmB,MAA5B,EAAoC1B,IAAIwB,CAAxC,EAA2CxB,GAA3C,EAAgD;AAC5C,YAAI2B,OAAOpC,MAAMgB,KAAN,CAAYP,CAAZ,EAAe,CAAf,CAAX;AACA,gBAAQ2B,IAAR;AACI,iBAAK,OAAL;AACIA,uBAAO,WAAP;AACA;AACJ,iBAAK,KAAL;AACIA,uBAAO,SAAP;AACA;AANR;AAQAF,kBACI,MAAM1C,WAAW4C,IAAX,CAAN,GAAyB,IAAzB,GAAgC5C,WAAWQ,MAAMgB,KAAN,CAAYP,CAAZ,EAAe,CAAf,CAAX,CAAhC,GAAgE,GADpE;AAEH;;AAED,WAAOyB,MAAP;AACH,CAxBD;;AA2BA;;;;;;;;;AASA9C,SAAS4C,SAAT,CAAmBT,WAAnB,GAAiC,SAASA,WAAT,CAAqB5B,MAArB,EAA6BC,GAA7B,EAAkCC,OAAlC,EAA2C;AACxE,QAAIwC,kBAAJ;AAAA,QACIH,SAAS,EADb;AAAA,QAEII,SAAS,KAFb;AAAA,QAGItC,QAASL,OAAOC,GAAP,CAHb;;AAKA;AACA,QAAII,MAAMuC,MAAV,EAAkB;AACd,eAAO,EAAP;AACH;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAIvC,MAAMwC,KAAN,IAAexC,MAAMyC,OAAN,KAAkB,CAAC,CAAlC,IAAuC7C,GAAvC,IAA8CD,OAAOC,MAAM,CAAb,EAAgB2C,MAAlE,EAA0E;AACtEL,kBAAU,IAAV;AACH;;AAED;AACAA,cAAU,CAAClC,MAAMyC,OAAN,KAAkB,CAAC,CAAnB,GAAuB,IAAvB,GAA8B,GAA/B,IAAsCzC,MAAM0C,GAAtD;;AAEA;AACAR,cAAU,KAAKjC,WAAL,CAAiBD,KAAjB,CAAV;;AAEA;AACA,QAAIA,MAAMyC,OAAN,KAAkB,CAAlB,IAAuB5C,QAAQ8C,QAAnC,EAA6C;AACzCT,kBAAU,IAAV;AACH;;AAED;AACA,QAAIlC,MAAMwC,KAAV,EAAiB;AACbF,iBAAS,IAAT;;AAEA,YAAItC,MAAMyC,OAAN,KAAkB,CAAtB,EAAyB;AACrB,gBAAI7C,MAAM,CAAN,GAAUD,OAAOwC,MAArB,EAA6B;AACzBE,4BAAY1C,OAAOC,MAAM,CAAb,CAAZ;;AAEA,oBAAIyC,UAAUO,IAAV,KAAmB,QAAnB,IAA+BP,UAAUE,MAA7C,EAAqD;AACjD;AACA;AACAD,6BAAS,KAAT;AAEH,iBALD,MAKO,IAAID,UAAUI,OAAV,KAAsB,CAAC,CAAvB,IAA4BJ,UAAUK,GAAV,KACI1C,MAAM0C,GAD1C,EAC+C;AAClD;AACA;AACAJ,6BAAS,KAAT;AACH;AACJ;AACJ;AACJ;;AAEDJ,cAAUI,SAAS,KAAT,GAAiB,GAA3B;;AAEA,WAAOJ,MAAP;AACH,CA3DD;;AA8DA;;;;;;;;AAQA9C,SAAS4C,SAAT,CAAmBa,YAAnB,GAAkC,UAAUlD,MAAV,EAAkBE,OAAlB,EAA2BC,GAA3B,EAAgC;AAC9D,QAAI8C,aAAJ;AAAA,QACIV,SAAS,EADb;AAAA,QAEIL,QAAS,KAAKA,KAFlB;;AAIA,SAAK,IAAIpB,IAAI,CAAR,EAAWqC,MAAMnD,OAAOwC,MAA7B,EAAqC1B,IAAIqC,GAAzC,EAA8CrC,GAA9C,EAAmD;AAC/CmC,eAAOjD,OAAOc,CAAP,EAAUmC,IAAjB;;AAEA,YAAI,OAAOf,MAAMe,IAAN,CAAP,KAAuB,WAA3B,EAAwC;AACpCV,sBAAUL,MAAMe,IAAN,EAAYjD,MAAZ,EAAoBc,CAApB,EAAuBZ,OAAvB,EAAgCC,GAAhC,EAAqC,IAArC,CAAV;AACH,SAFD,MAEO;AACHoC,sBAAU,KAAKX,WAAL,CAAiB5B,MAAjB,EAAyBc,CAAzB,EAA4BZ,OAA5B,CAAV;AACH;AACJ;;AAED,WAAOqC,MAAP;AACH,CAhBD;;AAmBA;;;;;;;;;;AAUA9C,SAAS4C,SAAT,CAAmBX,kBAAnB,GAAwC,UAAU1B,MAAV,EAAkBE,OAAlB,EAA2BC,GAA3B,EAAgC;AACpE,QAAIoC,SAAS,EAAb;;AAEA,SAAK,IAAIzB,IAAI,CAAR,EAAWqC,MAAMnD,OAAOwC,MAA7B,EAAqC1B,IAAIqC,GAAzC,EAA8CrC,GAA9C,EAAmD;AAC/C,YAAId,OAAOc,CAAP,EAAUmC,IAAV,KAAmB,MAAvB,EAA+B;AAC3BV,sBAAUvC,OAAOc,CAAP,EAAUP,OAApB;AACH,SAFD,MAEO,IAAIP,OAAOc,CAAP,EAAUmC,IAAV,KAAmB,OAAvB,EAAgC;AACnCV,sBAAU,KAAKb,kBAAL,CAAwB1B,OAAOc,CAAP,EAAUa,QAAlC,EAA4CzB,OAA5C,EAAqDC,GAArD,CAAV;AACH;AACJ;;AAED,WAAOoC,MAAP;AACH,CAZD;;AAeA;;;;;;;;;AASA9C,SAAS4C,SAAT,CAAmBe,MAAnB,GAA4B,UAAUpD,MAAV,EAAkBE,OAAlB,EAA2BC,GAA3B,EAAgC;AACxD,QAAIW,UAAJ;AAAA,QAAOqC,YAAP;AAAA,QAAYF,aAAZ;AAAA,QACIV,WADJ;AAAA,QAEIL,QAAS,KAAKA,KAFlB;;AAIA,SAAKpB,IAAI,CAAJ,EAAOqC,MAAMnD,OAAOwC,MAAzB,EAAiC1B,IAAIqC,GAArC,EAA0CrC,GAA1C,EAA+C;AAC3CmC,eAAOjD,OAAOc,CAAP,EAAUmC,IAAjB;;AAEA,YAAIA,SAAS,QAAb,EAAuB;AACnBV,sBAAU,KAAKW,YAAL,CAAkBlD,OAAOc,CAAP,EAAUa,QAA5B,EAAsCzB,OAAtC,EAA+CC,GAA/C,CAAV;AACH,SAFD,MAEO,IAAI,OAAO+B,MAAMe,IAAN,CAAP,KAAuB,WAA3B,EAAwC;AAC3CV,sBAAUL,MAAMlC,OAAOc,CAAP,EAAUmC,IAAhB,EAAsBjD,MAAtB,EAA8Bc,CAA9B,EAAiCZ,OAAjC,EAA0CC,GAA1C,EAA+C,IAA/C,CAAV;AACH,SAFM,MAEA;AACHoC,sBAAU,KAAKX,WAAL,CAAiB5B,MAAjB,EAAyBc,CAAzB,EAA4BZ,OAA5B,EAAqCC,GAArC,CAAV;AACH;AACJ;;AAED,kBACF,oBAAY,KAAKgC,OAAjB,EAA0BkB,GAA1B,CAA8BC,YAA9B,EAA4C,KAAKnB,OAAjD,EAA0DoB,IAA1D,CAA+D,KAA/D,CADE,UAEF,oBAAY,KAAKnB,OAAjB,EAA0BiB,GAA1B,CAA8BG,aAA9B,EAA6C,KAAKpB,OAAlD,EAA2DmB,IAA3D,CAAgE,EAAhE,CAFE,mIAOqBhB,MAPrB;AAUH,CA3BD;;AA6BA,SAASiB,aAAT,CAAuBC,GAAvB,EAA4B;AACxB,QAAMC,QAAQ,KAAKD,GAAL,CAAd;AACA,QAAI,CAACC,KAAL,EAAY;AACR,eAAO,EAAP;AACH;AACD,WAAOD,GAAP;AACH;;AAED,SAASH,YAAT,CAAsBG,GAAtB,EAA2B;AACvB,QAAMC,QAAQ,KAAKD,GAAL,CAAd;;AAEA,uBAAiBA,GAAjB,gBAA8BC,KAA9B;AACH","file":"markdown.js","sourcesContent":["/**\n * class Renderer\n *\n * Generates HTML from parsed token stream. Each instance has independent\n * copy of rules. Those can be rewritten with ease. Also, you can add new\n * rules if you create plugin and adds new token types.\n **/\n'use strict';\n\n\nconst assign      = require('markdown-it/lib/common/utils').assign;\nconst unescapeAll = require('markdown-it/lib/common/utils').unescapeAll;\nconst escapeHtml  = require('markdown-it/lib/common/utils').escapeHtml;\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst default_rules = {};\n\n\ndefault_rules.code_inline = function (tokens, idx, options, env, slf) {\n    const token = tokens[idx];\n\n    return '<code' + slf.renderAttrs(token) + '>{' + JSON.stringify(\n        tokens[idx].content) + '}</code>';\n};\n\n\ndefault_rules.code_block = function (tokens, idx, options, env, slf) {\n    const token = tokens[idx];\n\n    return '<pre' + slf.renderAttrs(token) + '><code>{' + JSON.stringify(\n        tokens[idx].content) + '}</code></pre>\\n';\n};\n\n\ndefault_rules.fence = function (tokens, idx, options, env, slf) {\n    const token = tokens[idx],\n          info  = token.info ? unescapeAll(token.info).trim() : '';\n\n    let langName = '',\n        highlighted, i, tmpAttrs, tmpToken;\n\n    if (info) {\n        langName = info.split(/\\s+/g)[0];\n    }\n\n    if (options.highlight) {\n        highlighted = options.highlight(token.content, langName) || escapeHtml(\n            token.content);\n    } else {\n        highlighted = escapeHtml(token.content);\n    }\n\n    if (highlighted.indexOf('<pre') === 0) {\n        return highlighted + '\\n';\n    }\n\n    // If language exists, inject class gently, without mudofying original\n    // token. May be, one day we will add .clone() for token and simplify this\n    // part, but now we prefer to keep things local.\n    if (info) {\n        i        = token.attrIndex('class');\n        tmpAttrs = token.attrs ? token.attrs.slice() : [];\n\n        if (i < 0) {\n            tmpAttrs.push(['className', options.langPrefix + langName]);\n        } else {\n            tmpAttrs[i][1] += ' ' + options.langPrefix + langName;\n        }\n\n        // Fake token just to render attributes\n        tmpToken = {\n            attrs: tmpAttrs\n        };\n\n        return highlighted;\n    }\n\n\n    return '<pre><code' + slf.renderAttrs(token) + '>'\n           + highlighted\n           + '</code></pre>\\n';\n};\n\n\ndefault_rules.image = function (tokens, idx, options, env, slf) {\n    const token = tokens[idx];\n\n    // \"alt\" attr MUST be set, even if empty. Because it's mandatory and\n    // should be placed on proper position for tests.\n    //\n    // Replace content with actual value\n\n    token.attrs[token.attrIndex('alt')][1] =\n        slf.renderInlineAsText(token.children, options, env);\n\n    return slf.renderToken(tokens, idx, options);\n};\n\n\ndefault_rules.hardbreak = function (tokens, idx, options /*, env */) {\n    return '<br />\\n';\n};\ndefault_rules.softbreak = function (tokens, idx, options /*, env */) {\n    return '<br />';\n};\n\n\ndefault_rules.text = function (tokens, idx /*, options, env */) {\n    return '{' + JSON.stringify(tokens[idx].content) + '}';\n};\n\n\ndefault_rules.html_block  = function (tokens, idx /*, options, env */) {\n    return tokens[idx].content;\n};\ndefault_rules.html_inline = function (tokens, idx /*, options, env */) {\n    return tokens[idx].content;\n};\n\n\n/**\n * new Renderer()\n *\n * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.\n **/\nexport default function Renderer() {\n\n    /**\n     * Renderer#rules -> Object\n     *\n     * Contains render rules for tokens. Can be updated and extended.\n     *\n     * ##### Example\n     *\n     * ```javascript\n     * const md = require('markdown-it')();\n     *\n     * md.renderer.rules.strong_open  = function () { return '<b>'; };\n     * md.renderer.rules.strong_close = function () { return '</b>'; };\n     *\n     * const result = md.renderInline(...);\n     * ```\n     *\n     * Each rule is called as independed static function with fixed signature:\n     *\n     * ```javascript\n     * function my_token_render(tokens, idx, options, env, renderer) {\n   *   // ...\n   *   return renderedHTML;\n   * }\n     * ```\n     *\n     * See [source\n     * code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)\n     * for more details and examples.\n     **/\n    this.rules = assign({}, default_rules);\n    this.imports = {\n        'React, {Component as $MDComponent}': 'react'\n    };\n    this.prelude = {};\n}\n\n\n/**\n * Renderer.renderAttrs(token) -> String\n *\n * Render token attributes to string.\n **/\nRenderer.prototype.renderAttrs = function renderAttrs(token) {\n    let i, l, result;\n\n    if (!token.attrs) {\n        return '';\n    }\n\n    result = '';\n\n    for (i = 0, l = token.attrs.length; i < l; i++) {\n        let name = token.attrs[i][0];\n        switch (name) {\n            case 'class':\n                name = 'className';\n                break;\n            case 'for':\n                name = 'htmlFor';\n                break;\n        }\n        result +=\n            ' ' + escapeHtml(name) + '=\"' + escapeHtml(token.attrs[i][1]) + '\"';\n    }\n\n    return result;\n};\n\n\n/**\n * Renderer.renderToken(tokens, idx, options) -> String\n * - tokens (Array): list of tokens\n * - idx (Numbed): token index to render\n * - options (Object): params of parser instance\n *\n * Default token renderer. Can be overriden by custom function\n * in [[Renderer#rules]].\n **/\nRenderer.prototype.renderToken = function renderToken(tokens, idx, options) {\n    let nextToken,\n        result = '',\n        needLf = false,\n        token  = tokens[idx];\n\n    // Tight list paragraphs\n    if (token.hidden) {\n        return '';\n    }\n\n    // Insert a newline between hidden paragraph and subsequent opening\n    // block-level tag.\n    //\n    // For example, here we should insert a newline before blockquote:\n    //  - a\n    //    >\n    //\n    if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n        result += '\\n';\n    }\n\n    // Add token name, e.g. `<img`\n    result += (token.nesting === -1 ? '</' : '<') + token.tag;\n\n    // Encode attributes, e.g. `<img src=\"foo\"`\n    result += this.renderAttrs(token);\n\n    // Add a slash for self-closing tags, e.g. `<img src=\"foo\" /`\n    if (token.nesting === 0 && options.xhtmlOut) {\n        result += ' /';\n    }\n\n    // Check if we need to add a newline after this tag\n    if (token.block) {\n        needLf = true;\n\n        if (token.nesting === 1) {\n            if (idx + 1 < tokens.length) {\n                nextToken = tokens[idx + 1];\n\n                if (nextToken.type === 'inline' || nextToken.hidden) {\n                    // Block-level tag containing an inline tag.\n                    //\n                    needLf = false;\n\n                } else if (nextToken.nesting === -1 && nextToken.tag\n                                                       === token.tag) {\n                    // Opening tag + closing tag of the same type. E.g.\n                    // `<li></li>`.\n                    needLf = false;\n                }\n            }\n        }\n    }\n\n    result += needLf ? '>\\n' : '>';\n\n    return result;\n};\n\n\n/**\n * Renderer.renderInline(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * The same as [[Renderer.render]], but for single token of `inline` type.\n **/\nRenderer.prototype.renderInline = function (tokens, options, env) {\n    let type,\n        result = '',\n        rules  = this.rules;\n\n    for (let i = 0, len = tokens.length; i < len; i++) {\n        type = tokens[i].type;\n\n        if (typeof rules[type] !== 'undefined') {\n            result += rules[type](tokens, i, options, env, this);\n        } else {\n            result += this.renderToken(tokens, i, options);\n        }\n    }\n\n    return result;\n};\n\n\n/** internal\n * Renderer.renderInlineAsText(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Special kludge for image `alt` attributes to conform CommonMark spec.\n * Don't try to use it! Spec requires to show `alt` content with stripped\n * markup, instead of simple escaping.\n **/\nRenderer.prototype.renderInlineAsText = function (tokens, options, env) {\n    let result = '';\n\n    for (let i = 0, len = tokens.length; i < len; i++) {\n        if (tokens[i].type === 'text') {\n            result += tokens[i].content;\n        } else if (tokens[i].type === 'image') {\n            result += this.renderInlineAsText(tokens[i].children, options, env);\n        }\n    }\n\n    return result;\n};\n\n\n/**\n * Renderer.render(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Takes token stream and generates HTML. Probably, you will never need to call\n * this method directly.\n **/\nRenderer.prototype.render = function (tokens, options, env) {\n    let i, len, type,\n        result = ``,\n        rules  = this.rules;\n\n    for (i = 0, len = tokens.length; i < len; i++) {\n        type = tokens[i].type;\n\n        if (type === 'inline') {\n            result += this.renderInline(tokens[i].children, options, env);\n        } else if (typeof rules[type] !== 'undefined') {\n            result += rules[tokens[i].type](tokens, i, options, env, this);\n        } else {\n            result += this.renderToken(tokens, i, options, env);\n        }\n    }\n\n    return `\n${Object.keys(this.imports).map(renderImport, this.imports).join(';\\n')}\n${Object.keys(this.prelude).map(renderPrelude, this.prelude).join('')}\n//autogenerated class\nexport default class Markdown extends $MDComponent {\n\n        render(){\n          return (<div>${result}</div>);\n        }\n}`;\n};\n\nfunction renderPrelude(key) {\n    const value = this[key];\n    if (!value) {\n        return '';\n    }\n    return key;\n}\n\nfunction renderImport(key) {\n    const value = this[key];\n\n    return `import ${key} from '${value}'`;\n}\n\n\n"]}
