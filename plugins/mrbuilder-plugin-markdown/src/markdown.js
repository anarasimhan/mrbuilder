/**
 * class Renderer
 *
 * Generates HTML from parsed token stream. Each instance has independent
 * copy of rules. Those can be rewritten with ease. Also, you can add new
 * rules if you create plugin and adds new token types.
 **/
'use strict';
const { camelCased } = require('mrbuilder-utils');

const escapeHtml   = require('markdown-it/lib/common/utils').escapeHtml;
const _Renderer    = require('markdown-it/lib/renderer');
const reactReplace = (str) => str.replace(/'/g, "\\'")
                                 .replace(/\${/g, "${'${'}");

const reactStyle = (value) => {
    return `{${JSON.stringify(
        value.split(/;/g).reduce(function (ret, key) {

            const parts = key.split(':', 2);

            ret[camelCased(parts[0])] = parts[1];

            return ret;
        }, {})).replace(/^"(.*)"$/, '$1')}}`;
};

class Renderer extends _Renderer {
    constructor(...args) {
        super(...args);

        this.prelude              = {};
        this.imports              = {
            'React, {Component as $MDComponent}': 'react'
        };
        this.renderImport         = this._renderImport.bind(this);
        this.renderPrelude        = this._renderPrelude.bind(this);
        this.rules['text']        = this.text;
        this.rules['html_inline'] = this.inlineHtml.bind(this);
        this.rules['html_block']  = this.blockHtml.bind(this);
    }

    blockHtml(tokens, idx) {
        const current = tokens[idx];
        return current.content;
    }

    inlineHtml(tokens, idx) {
        const content  = tokens[idx].content;
        const tagParts = /^<(.*)\s+?(.*)\/?>$/.exec(content);
        if (tagParts == null) {
            return content;
        }
        const tag   = tagParts[1];
        const attrs = (tagParts[2] || '').replace(
            /((\S+)=["']?((?:.(?!["']?\s+(?:\S+)=|[>"']))+.)["']?)/g,
            (m, i2, k, v) => {
                if (k === 'style') {
                    return `style=${reactStyle(v)}`;
                }
                return m;
            });
        return `<${tag} ${attrs}>`;
    };

    text(tokens, idx /*, options, env */) {
        return `{'${escapeHtml(reactReplace(tokens[idx].content))}'}`;
    }


    /**
     * Renderer.renderAttrs(token) -> String
     *
     * Render token attributes to string.
     **/
    renderAttrs(token) {
        let i, l, result;

        if (!token.attrs) {
            return '';
        }

        result      = '';
        const attrs = [];
        for (i = 0, l = token.attrs.length; i < l; i++) {
            let [name, value] = token.attrs[i];
            switch (name) {
                case 'class':
                    name  = 'className';
                    value = `"${escapeHtml(value)}"`;
                    break;
                case 'for':
                    name  = 'htmlFor';
                    value = `"${escapeHtml(value)}"`;
                    break;
                case 'style':
                    value = reactStyle(value);
                    break;
                default:
                    value = `"${escapeHtml(value)}"`;
                    break;
            }
            attrs.push([name, value]);
        }

        for (i = 0, l = attrs.length; i < l; i++) {
            const [name, value] = attrs[i];
            result += ' ' + escapeHtml(name) + '=' + value;
        }

        return result;
    }


    render(tokens, options, env) {
        let i, len, type,
            result = ``,
            rules  = this.rules;

        for (i = 0, len = tokens.length; i < len; i++) {
            type = tokens[i].type;

            if (type === 'inline') {
                result += this.renderInline(tokens[i].children, options, env);
            } else if (typeof rules[type] !== 'undefined') {
                result += rules[tokens[i].type](tokens, i, options, env, this);
            } else {
                result += this.renderToken(tokens, i, options, env);
            }
        }

        return `
${Object.keys(this.imports).map(this.renderImport, this.imports).join(';\n')}
${Object.keys(this.prelude).map(this.renderPrelude, this.prelude).join('')}
//autogenerated class
export default class Markdown extends $MDComponent {
        render(){
          return (<div {...this.props}>${result}</div>);
        }
}`;
    }


    _renderPrelude(key) {
        const value = this.prelude[key];
        if (!value) {
            return '';
        }
        return key;
    }

    _renderImport(key) {
        return `import ${key} from '${ this.imports[key]}'`;
    }
}

module.exports = Renderer;
